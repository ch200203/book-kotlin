## 2.1 기본 문법

#### 주석.
자바와 마찬가지로 코틀린은 세 가지 주석을 지원하며, 코드를 문서화할 때 사용한다.
* 한 줄짜리 주석 : //로 시작하며 줄이 끝나면 주석도 끝이난다.
* 여러 줄 주석 : /*로 시작하고 */로 끝난다.
* KDoc 여러 줄 주석 : /**로 시작하고 */로 끝난다.
***

#### 변수 정의하기.
코틀린에서 변수의 정의를 이루는 요소들은 아래와 같다.
* val 키워드 : 값을 뜻하는 value에서 유래했다.
* 변수 식별자 : 새 변수에 이름을 부여하고, 나중에 이를 가리킬 때 사용한다.
* 변수의 초깃값을 정의하는 식 : = 기호 뒤에 온다

※ 코틀린에서는 변수 정의 뒤에 세미콜론(;)을 생략해도 된다.

**타입 추론이란.**
* 대부분의 경우 컴파일러가 코드의 문맥에서 타입을 도출해주는 언어의 기능으로 여기서 컴파일러는
toInt() 함수가 Int 타입의 값을 반환한다는 사실을 알고 있으며, 이 결과를 변수에 대입했기 때문에
변수 타입을 Int로 추론을 하는 것을 의미한다.

``` ex) var size = 100 ```

또한 필요할 때에는 아래와 같이 타입을 명시하여 사용할 수 있다.

```  
    val size: Int = 100
    val text: String = "Bonhyeok.koo"
```
***

#### 식별자 
식별자는 변수나 함수 등 프로그램에 정의된 대상에 붙은 이름이다. 코틀린의 식별자는 자바 식별자와 비슷하며
아래의 규칙을 만족하는 임의의 문자열이다.
* 식별자는 오직 문자, 숫자, 밑줄 문자(_)만 포함한다. 숫자로 식별자를 시작할 수는 없다.
* 밑줄로만 이뤄질 수도 있다. 하지만 이런 식별자(_,__,___등)는 모두 미리 예약된 식별자이므로 일반적인
식별자로는 사용될 수 없다.
* 하드 키워드를 식별자로 쓸 수는 없다. 하드 키워드(val, fun 등)는 코드 어디에든  키워드로 간주된다.
***

#### 가변 변수
* 불변 변수 : 한번 초기화하면 다시는 값을 대입 할 수 없는 변수이다. 이는 자바에서 **final** 변수와 비슷하며,
불변 변수를 사용하면 함수가 부수 효과를 일으키지 못하고, 함수형 스타일 코드를 장려할 수 있으며, 이로 인해
코드에 대한 추혼이 쉬워진다.
* 가변 변수 : 초기에 값을 세팅 후 해당 값을 언제든 변경 할 수 있다.

```kotlin
    var sum = 1
    sum = sum + 2
    sum = sum + 3
```

코틀린은 복합 대입 연산이라는 대입과 +, -, *, /, % 등의 이항 연산을 조합한 연산도 제공을 한다.
```kotlin
    var reesult = 3 
    result += 10        // result = result * 10
    result += 6         // result = result + 6
```
이런 대입 연산은 복합 대입 연산의 대상이 되는 변수에 대해 이항 연산자가 쓰일 수 있을 때만 가능하다.
***

#### 식과 연산자
지금까지 사용한 코틀린의 식을 다음과 같이 분류할 수 있다.
* 각 타입에 속하는 구체적인 값을 표현하는 리터럴
* 변수/프로퍼티 참조와 함수 호출(a, readLine(), "abc".length, "12".toInt() )
* 전위와 후위 단항 연산( -a, ++b, c-- )
* 이항 연산( a+ b, 2 * 3, x < 1 )


## 2.2 기본 타입

#### 정수 타입
코틀린에는 정수를 표현하는 네 가지(Byte, Short, Int, Long) 기본 타입이 있다.
***

#### 부동소수점 수 
자바와 마찬가지로 코틀린도 IEEE 754 부동소수점 수를 따르는 Float와 Double을 제공한다.

부동소수점 수 리터럴 중 가장 단순한 형태는 10진 소수 형태로, 정수 부분과 소수 부분을 나눠
소수점(.)을 찍어 놓았다.
```kotlin
    val pi = 3.14
    val one = 1.0
```
정수 부분이 비어있는 경우 정수 부분을 0으로 간주한다. 하지만 소수점을 남기면서 소수 부분을 생략할 수는 없다.
```kotlin
    val quarter = .25           // 0.25
    val one = 1.                // Error : Expection an element
    val two = 2                 // 오류는 아니지만 정수 리터럴
```
디폴트로 부동소수점 리터럴은 Double 타입이다. f나 F를 리터럴 뒤에 붙이면 Float 타입이 된다.
```kotlin
    val pi = 3.14f
    val one = 1f
```


자바에서는 D나 d를 부동소수점 리터럴 뒤에 붙여서 강제로 double 타입으로 만들 수 있다. 하지만 코틀린에서는
이런 접미사를 허용하지 않으며, 부동소수점 리터럴의 타입은 디폴트로 Double이다.

Float와 Double도 각 타입의 특별한 값을 표현하는 몇가지 상수를 제공한다.
* MIN_VALUE, MAX_VALUE : 각 타입에서 표현할 수 잇는 가장 작은 유한값과 가장 큰 유한값
* NEGAATIVE_INFINITY, POSITIVE_INFINITY : 음의 무한대와 양의 무한대, 각 타입이 표현할 수 있는
가장 작은 값과 가장 큰 값.
* NaN : 0/0의 결과처럼 숫자가 아닌 값을 의미.
***

#### 산술 연산
**산술 연산의 동작은 자바와 같다.**

코틀린 1.5부터 표준라이브러리 정수 floorDiv()와 mod() 메서드가 추가됐다.
```kotlin
    7.floorDiv(4)               // 1
    (-7).floorDiv(4)            // -2
    7.floorDiv(-4)              // -2
    (-7).floorDiv(-4)           // 1
    7.mod(4)                    // 3
    (-7).mod(4)                 // 1
    7.mod(-4)                   // -1
    (-7).mod(-4)                // -3
```
***

#### 비트 연산
 비트 연산은 Int와 Long은 비트 수준의 연산을 지원한다.  
 자바에 익숙하다면 비트 연산자 &,~, <<, >>, >>>를 알 텐데, 코틀린은 이런 연산자를 지원하지 않는다.
 대신 이에 대응하는  and, or, xor, inv, shl, shr, ushr을 사용해야 한다.
 
***
#### 문자 타입  Char
 자바에서는 문자(char)에 대한 산술 연산 결과가 암시적으로 정수로 변환된다. 반면 코들린에서 Char에
 대한 연산은( 두 문자의 차이는 제외 ) Char를 결과로 돌려준다.
***

#### 불 타입과 논리 연산
코틀린은 참(true)이나 거짓(false) 중 하나로 판명되는 불(boolean) 타입과 논리 연산을 제공한다.
```kotlin
    val hasErrors = false;
    val testPassed = true;
```
자바와 마찬가지로 코틀린 Boolean도 수 타입과는 다른 타입이며, 암시적으로든 toInt() 등의 명시적인
내장 연산을 써서든 수로 변환할 수 없다. 개발자는 비교 연산자나 조건식을 사용해 불이 아닌 값에서
불 값을 만들어야 한다. 불(Boolean)이 지원하는 연산자는 다음과 같다.  
* ! : 논리 부정
* or, and, xor : 즉시 계산 방식의 논리합, 논리곱, 논리배타합
* ||, && : 지연 계산 방식의 논리합, 논리곱

``자바와 달리 코틀린은 &와 | 연산자를 제공하지 않는다. and와 or가 각각 &와 |를 대신한다.``
***

#### 비교와 동등성
  지금까지 언급한 모든 타입은 몇 가지 비교 연산을 제공한다. ==(같다), !-(같지 않다)
  <(~보다 작다), <=(~보다 작거나 같다), >(~보다 크다), >=(~보다 크거나 같다)가 비교 연산이다.
  
자바에서는 박싱된 값과 언박싱된 값이 서로 다른 타입으로 표현됐고, 원시 타입의 값을 자유롭게 서로
==, !=나 <, <=, >, >=로 비교할 수 있었다. 하지만 자바의 불 값은 순서가 없기 때문에 두 불 값에
대해서는 동등성 비교만 적용할 수 있다.
***

## 2.3 문자열 

#### 문자열 템플릿
문자열 리터널을 정의하는 가장 간단한 방법은 앞에서 본 것처럼 자바와 마찬가지로 큰따옴표(")로
문자열을 감싸는 것이다.
```
    val hello = "Hello, world!" 
```
***

#### 기본 문자열 연산
모든 String 인스턴스는 문자열에 든 문자 수를 표현하는 length와 문자열의 마지막 문자 인덱스를
표현하는 lastIndex 프로퍼티를 제공한다.
```kotlin
    "Hello!".length         // 6
    "Hello!".lastIndex      // 5

    val s1 = "Hello!"
    val s2 = "Hel"+"lo!"
    println( s1 == s2 )     // true
```
  
자바의 ==와 != 연산자는 참조 동긍성을 비교하기 때문에 실제 문자열 내용을 비교하려면 equals()
메소드를 사용해야 한다. 코틀린에서는 ==가 기본적으로 equals()를 가리키는 편의 문법이기 때문에
==를 사용하면 직접 equals()를 호출하므로 따로 equals()를 호출할 필요가 없다. 널 가능성을
논의에서 배제하면, 위 코드는 자바의 s1.equals(s2)와 같다. 코틀린에서 참조 동등성을 쓰고 싶으면
===와 !=== 연산자를 사용하면 된다.


다음은 문자열이 제공하는 다른 유용한 함수들이다.
* isEmpty, isNotEmpty : 문자열이 비어있는지 검사한다.
* subString : 부분 문자열을 추출한다.
* startWith, endWith : 접두사(prefix)나 접미사(suffix)인지 검사한다.
* indexOf : 인자로 받은 문자나 문자열이 수신 객체인 문자열에 나타나는 첫번째 인덱스를 반환하다.
***

## 2.4 배열

#### 배열 정의하기
배열 구조를 구현하는 가장 일반적인 코틀린 타입은 Array<T>이다.
```kotlin
    val a = emptyArray<String>()            // 원소 0개
    val b = arrayOf("hello", "world")       // 원소 2개
    val c = arrayOf(1, 4, 9)                // 원소 3개
```
Array<Int>를 사용하는 배열은 제대로 작동하지만 모든 수를 박싱하기 때문에 그다지 실용적이지 못한 해법이다.
이런 이유로 코틀린은 더 효율적인 ByteArray, ShortArray, IntArray, LongArray, FloatArray,
DoubleArray, Char Array, BooleanArray라는 특화된 배열 타입을 제공한다. JVM에서 이런 배열
타입들은 int[], boolean[] 등의 원시 타입 배열로 표현한다. 이런 특화된 배열에도 arryOf()나 Array()에
해당하는 함수가 함께 따라온다.
```kotlin
    val operrations = charArrayOf('+', '-', '*', '/', '%')
    val squares = IntArray<10>{ ( it + 1 )*( it + 1 ) }
```

자바와 달리 코틀린에는 new 연산자가 없기 때문에 배열 인스턴스 생성이 일반 함수 호출처럼 보인다.
코틀린에서는 배열 원소를 명시적으로 초기화해야 한다는 점에도 유의해야 한다.
***

#### 배열 사용하기

배열 타입은 문자열 타입과 꽤 비슷하다. 특히 size와 lastIndex 프로퍼티가 있다는 점과 인덱스 연산으로 원소에
접근할 수 있다는 점이 비슷하다. 잘못된 인덱스를 사용하면 런타임에 IndexOutofBoudsException 예외가 발생한다.
```kotlin
    val squares = arrayOf(1, 4, 9, 16)
    squares.size                // 4
    squares.lastIndex           // 3
    squares[3]                  // 16
    squares[1]                  // 4
```
하지만 문자열과 달리 배열에서는 원소를 변경할 수 있다.
```kotlin
    squares[2] = 100        // 1, 4, 100, 16
    squares[3] += 9         // 1, 4, 100, 25
    squares[0--]            // 0, 4, 100, 25
```
그리고 원본과 별도로 배열을 만들고 싶다면 copyOf() 함수를 사용해야 한다. copyOf()는 필요시
다른 크기의 배열을 만들어내기도 한다.
```kotlin
    val numbers = squares.copyOf()
    numbers[0] = 1000           // squares에는 영향이 없다
    squares.copyOf(2)           // 뒤가 잘림: 1, 4
    squares.copyOf(5)           // 부족한 부분에 0이 채워짐 1, 4, 9, 16, 0
```
배열을 생성하고 나면 그 길이를 바꿀 수 없지만, + 연산을 사용해 원소를 추가한 새로운 배열을 만들 수는 있다.
```kotlin
    val b = intArrayOf(1, 2, 3) + 4                 // 원소를 하나만 추가 : 1, 2, 3, 4
    val c = intArrayOf(1, 2, 3) + intArrayOf(5, 6)  // 다른 배열을 추가 : 1, 2, 3, 5, 6
```
문자열과 달리 배열에 대한 ==와 != 연산자는 원소 자체를 비교하지 않고 참조를 비교한다.  
배열 내용을 비교하고 싶으면 contentEquals() 함수를 사용한다.
``` kotlin
    intArrayOf(1, 2, 3) == intArrayOf(1, 2, 3)   // false
    
    intArrayOf(1, 2, 3).contentEquals(intArrayOf(1, 2, 3)) // true
 ```
배열을 사용할 때는 아래의 항목들이 도움이 될 것이다.
* isEmpty : 배열이 비어있는지 검사
* isNotEmpty : 배열에 원소가 있는지 검사
* indexOf : 인자와 일치하는 최초의 배열 아이템의 인덱스를 반환.
***



    
