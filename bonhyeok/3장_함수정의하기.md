## 함수 
 *  자바 메서드처럼 코틀린 함수도 어떤 입력을 받아서 자신을 호출한 코드 쪽에 출력값을 반환할 수 있는 재사용 가능한 코드 블록이다.

---
#### 코틀린 함수의 구조
자바와 마찬가지로 함수의 결과값을 return 문으로 지정한다. return 문은 함수 실행을 끝내고 호출한 쪽에 제어를
돌려준다. return 문 다음에 위치한 코드는 실질적으로 죽어있는 코드이며, 결코 실행되지 않는다.  

자바처럼 코틀린에도 블록 문이 있다. 블록 문은 기본적으로 {}로 감싼 문의 그룹을 말한다. 
문은 새줄 문자로 분리하거나 세미콜론으로 분리하며, 순서대로 실행된다.

```kotlin
    fun increment(n: Int): Int{
        return n++      // Error : can not change immutable variable
    }
```
자바 메서드 파라미터는 디폴트가 가변이므로 함수 내부에서 변경하지 못하게 하려면 final을 지정해 불변 값으로
바꿔야 하는데, 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하하면 위의 코드 같이 오류가 발생한다.
그리고 파라미터 앞에 **val이나 var**를 표시할 수 없다는 점을 유의하라. 이렇게 강제하는 이유는 
파라미터에 대입하는 중에 실수할 가능성이 높을 뿐 아니라 파라미터를 불변 값으로 강제하는 편이 더 깔끔하고
이해하기 편한 코드를 만들어 내기 때문이다.

```kotlin
    fun increment(a: IntArray): Int{
        return ++a[0]
    }

    fun main(){
        val a = intArrayOf(1, 2, 3)
        println( increment(a) )             // 2
        println( a.contentToString() )      // [2, 2, 3]
    }
```
하지만 파라미터가 참조(배열 타입)라면 호출한 쪽의 데이터는 그대로 남아있고 이 데이터에 대한 참조만 복사된다.
따라서 파라미터 자체는 함수 내부에서 바뀔 수 없지만, 일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다.


또한 타입 지정을 생략해도 되는 변수와 달리 파라미터에는 항상 타입을 지정해야 한다. 컴파일러는 함수 정의에서
파라미터 타입을 추론하지 못한다.

그리고 경우에 따라 반환 타입을 생략할 수 있는데, 이런 예외적인 경우는 2가지가 있다. 하나는 유닛(unit) 타입을
반환하는 경우다. 유닛은 자바  void에 해당하는 코틀린 타입으로, 함수가 의미있는 반환값을 돌려주지 않는다는 뜻이다.
```kotlin
    fun prompt(name: String){
        println("####Hello, $name")
    }

    fun prompt(name: String): Unit {
        println("####Hello, $name")
    }
```
***

#### vararg 
vararg는 함수 매개변수에 가변 인자를 허용하는 키워드 입니다. 이를 통해 함수에 여러 개의 인자를 전달할 수
있으며, 자바의 가변 인자와 유사한 기능을 제공한다.

```kotlin
    fun printSorted(vararg items: Int){
        items.sort()
        println(items.contentToString())
    }
    
    fun main() {
        printSorted(6, 2, 10, 1)  // 1, 2, 6, 10
    }
```
또한, 스프레드 연산자인 *를 사용하면 배열을 가변 인자 대신 넘길 수 있다.
```kotlin
    val number = intArrayOf(6, 2, 10, 1)
    printSorted(*number)
    printSorted(number)// Error: passing IntArray instead of Int
```
스프레드는 배열을 본사한다는 점에 유의하라. 따라서 파라미터 배열의 내용을 바꿔도 원본 원소에는 영향을 미치지 않는다.
```kotlin
    fun main(){
        val a = intArrayOf(6, 2, 10, 1)
        printSorted(*a)         // [1, 2, 6, 10]
        printSorted(a.contentToString()) // [6, 2, 10 ,1]
    }
```
하지만 이때 얕은 복사가 이뤄진다. 즉, 배열 내부에 참조가 들어있는 경우에는 참조가 복사되기 때문에 
참조가 가리키는 데이터가 호출하는 쪽과 함수 내부 배열에서 공유된다.
```kotlin
    fun change(vararg items: IntArray){
        println(items[0].contentToString())
        println(items[1].contentToString())
    
        items[0][0] = 100
    }
    
    fun main() {
        val a = intArrayOf(1, 2, 3)
        val b = intArrayOf(4, 5, 6)
    
        change(a, b)
        println( a.contentToString() )
        println( b.contentToString() )
    
    }
```
```text
kotlin에서 'vararg'는 함수에 가변 인자를 전달 할 수 있도록 해주는 
키워드이며, 가변 인자는 함수에 전달할 인자의 개수가 정해져 있지 않고,
필요에 따라 얼마든지 전달할 수 있는 인자이다.
```
***

#### 함수의 영역과 가시성
코틀린 함수는 정의된 위치에 따라 세 가지로 구분할 수 있다.
1. 파일에 직접 선언된 최상위 함수
2. 어떤 타입 내부에 선언된 멤버 함수
3. 다른 함수 안에 선언된 지역 함수
  
public이라는 변경자도 있다. 하지만 최상위 함수는 디폴트로 공개 가시성을 갖기 때문에 변경자는 불필요한
중복일 뿐이다.  
지역 변수처럼 함수 내부에 지역 함수를 정의할 수 있으며, 이 함수의 영역은 함수를 감싸는 블록으로 한정된다.
```kotlin
    fun main(){
        fun readInt() = 5
        
        println( readInt() + readInt() + 1)
    }
    
    fun readIntPairMain() = intArrayOf( readInt(), readInt()) // error: unresolved reference: readInt
```
지역 함수는 자신을 둘러싼 함수, 블록에 선언된 변수나 함수에 접근할 수 있다. 이런 변수에는 지역 함수를 둘러싸고
있는 함수의 파라미터도 포함된다.
```kotlin
    fun main(){

        fun swap(i: Int, j: Int): String{
             val chars:CharArray = "bonhyeok".toCharArray()
             val tmp = chars[i]
            chars[i] = chars[j]
            chars[j] = tmp
            return chars.concatToString()
        }
        println( swap(0, "bonhyeok".lastIndex) )
    }
```

***

## 3.2 패키지와 임포트

#### 패키지와 디렉터리 구조
코틀린 파일에서도 맨 앞에 패키지 이름을 지정하면 파일에 있는 모든 최상위 선언을 지정한 패키지 내부에 넣을 수 
있다. 패키지를 지정하지 않으면 컴파일러는 파일이 디폴트 최상위 패키지에 속한다고 가정한다. 디폴트 최상위
패키지는 이름이 없다.
  
패키지를 이루는 최상위 선언에는 타입, 함수, 프로퍼티가 있다. 같은 패키지 안에서는 간단한 이름을 사용해 패키지
내에 있는 다른 정의를 참조할 수 있다. 
```kotlin
package foo.bar.kotlinVerse

fun readInt(radix: Int = 10) = readLine()!!.toInt(radix)
```
```kotlin
package foo.bar.kotlinVerse

fun main(){
    println(readInt(8))
}
```
***
#### 임포트 디렉티브 사용하기
이번 절에서는 코틀린이 제공하는 여러 가지 임포드 디렉티브를 소개하고 각각 자바의 비슷한 기능과 어떻게 다른지 살펴본다.  
지금까지 예제에서 봤던 가장 단순한 임포트 형태는 전체 이름을 지정해 어떤 선언을 임포트 하는 것이다.
```kotlin
import java.lang.Math       // JDk 클래스
import foo.bar.util.readInt // 최상위 함수
```
임포트 디렉티브가 클래스나 함수 등의 최상위 선언만 임포트할 수 있는 것은 아니다. 클래스 안에 내포된 클래스나
다음 예제처럼 이넘 상수등도 임포트할 수 있다.
```kotlin
import kotlin.Int.Companion.MIN_VALUE
fun fromMin(steps: Int) = MIN_VALUE + n // MIN_VALUE를 간단한 이름으로 가리킴
```
* 자바와 달리 코틀린의 타입 멤버를 임포트하는 별도의 import static 디렉티브가 없다. 코틀린의 모든 선언은 
일반적인 임포트 디렉티브 구문을 사용해 임포트할 수 있다.

서로 다른 패키지에 있는 일부 선언의 이름은 똑같을 수도 있다. 이런 이름들을 한 파일에서 쓰려면 아래의 코드처럼
작성하여 사용을 할 수 있다.
```kotlin
import app.util.foo.readInt
import app.util.bar.readInt

fun main(){
    val n = readInt() // 오류: 두 가지 readInt() 중 하나만 선택할 수 없음
}
```
이 둘을 구분하려면 항상 전체 이름을 사용해야 한다. 하지만 코틀린은 임포트 별명(alias)이라는 더 나은 해법을 제공한다.
```kotlin
import app.util.foo.readInt     as fooReadInt
import app.util.bar.readInt     as barReadInt

fun main(){
    val n = fooReadInt()
    val m = barReadInt()
}
```
그리고 또 다른 형태인 임포트로 어떤 영역에 속한 모든 선언을 한꺼번에 임포트할 수 있다.
```kotlin
import kotlin.math.*
```
****

## 3.3 조건문

#### if 문으로 선택하기
코틀린의 if는 자바 if 문과 비슷한 문법을 제공한다.  
코틀린의 if와 자바 if 문은 비슷한 문법을 제공하지만 코틀린의 if를 식으로 사용할 수 있다는 특징이 있다.
```kotlin
fun max(a: Int, b: Int): Int{
    if(a > b) return a
    else return b
}

// if를 식으로 사용.
fun max(a: Int, b: Int) = if (a > b) a else b
```
그리고 if 문을 식으로 사용할 때는 양 가지 모두 있어야 한다. else 가지가 없기 때문에 다음 코드는
컴파일되지 않는다.  

```
val max = if(a > b) // error: 'if'' must have both main 
and 'else' branches if used as an expression
```
***

#### 범위, 진행, 연산
코틀린은 순서가 정해진 값 사이의 수열을 표현하는 몇 가지 타입을 제공한다. for 루프로 어떤 수 범위를
반복해야 할 때는 이런 타입이 유용하다. 코틀린에서는 이런 타입을 범위라고 부른다.
```kotlin
val chars = 'a'..'h'        // 'a'부터 'h'까지의 모든 문자
val twoDigits = 10..99      // 10부터 99까지의 모든수
val zero2One = 0.0..1.0     // 0부터 1까지의 모든 부동소수점
```
in 연산을 사용하면 어떤 값이 범위 안에 들어있는지 알 수 있다. 기본적으로는 한 쌍의 비교식을
조합한 것과 같다.
```kotlin
val num = readLine()!!.toInt()
println(num in 10..99)     // num >= 10 && num <= 99
println(num !in 10..99)    // !(num in 10..99
```
범위와 연관이 있는 개념으로 진행이 있다. 진행은 정해진 간격만큼 떨어져 있는 정수나 Char 값들로 이뤄진
시퀀스를 말한다. 정수나 Char에 대해 정의된 법위는 실제로는 간격이 1인 진행이라 할 수 있다.
하지만 일반적으로 진행이 범위보다 더 많은 옵션을 제공한다. 예를 들어 다음 코드처럼 downTo 연산을
사용하면 아래로 내려가는 진행을 만들 수 있다.
```kotlin
println(5 in 10 downTo 1)       // true
println(5 in 1 downTo 10)       // false
```
그리고 진행의 간격을 지정할 수도 있다.  
진행의 간격은 양수여야하며, 아래의 예제처럼 downTo와 step으로 진행을 만들 때도 양수를 써야 한다.
```kotlin
1..10 step 3        // 1, 4, 7, 10
15 downTo 9 step 2  // 15, 13, 11 ,9
```
in/!in 연산을 지원하는 타입이 범위만 있는 것은 아니다. 문자열이나 배열처럼 다른 타입의 원소를 
담는 컨테이너 종류의 타입이라면 보통 이 두 연산을 지원한다.
```kotlin
val numbers = intArrayOf(3, 7, 2, 1)
val text = "Hello!"
println(2 in numbers)       // true
println(9 !in numbers)      // true
println(4 in numbers)       // false
println('a' in text)        // false
println('H' in text)        // true
println('h' !in text)        // true 
```
***

#### when 문과 여럿 중에 하나 선택하기
코틀린 when은 여러 대안 중 하나를 선택한다는 점에서 자바 switch 문과 비슷하다. 하지만 가장 중요한
차이는 when에서는 임의의 조건을 검사할 수 있지만 switch에서는 주어진 식의 여러 가지 값 중 하나만 
선택할 수 있다는 점이다. 추가로 자바의 switch 문은 폴스루라는 의미를 제공한다. 어떤 조건을 만족할 
때 프로그램이 해당 조건에 대응하는 문을 실행하고 명시적으로 break를 만날 대까지 그 이후의 모든 
가지를 실행하는데, 이를 폴스루라고 한다. 코틀린 when은 조건을 만족하는 가지만 실행하고 절대 폴스루를
하지 않는다.

if 문으로 작성된 코드를 아래의 방식처럼 when 문으로 변경을 할 수 있다.
```kotlin
// if를 사용한 예제 코드
fun hexDigit(n: Int): Char{
    if(n in 0..9) return '0' + n
    else if(n im 10..15) return 'A' + n - 10
    else return '?'
}
// when을 사용한 예제 코드
fun hexDigit(n: Int): Char{
    when {
        n in 0..9 -> return '0' + n
        n in 10..15 -> return 'A' + n - 10
        else -> return '?'
    }
}
```
***

## 3.4 루프

#### while과 do-while 루프
```kotlin
fun main(){
    var sum = 0
    var num
    
    do{
        num = readln()!!.toInt()
        sum += num
    }while( num != 0 )
    
    println("Sum: $sum")
}
```
do-while 루프는 다음 규칙에 따라 평가된다.
1. do와 while 키워드 사이에 있는 루프 몸통을 실행한다.
2. while 키워드 다음에 있는 조건을 평가한다. 이 값이 참이면 1번 단계로 되돌아가고, 이 값이
거짓이면 루프 문 다음에 있는 문을 실행한다.

루프 몸통을 실행한 다음에 조건을 검사하프로 루프 몸통이 최소 한 번은 실행된다는 사실에 유의하자.
***

#### for 루프와 이터러블
코틀린의 for 루프를 사용하면 컬렉션과 비슷하게 여러 값이 들어있을 수 있는 값에 대한 루프를 수핼할
수 있다. 예를 들어 배열 원소에 대한 for 루프를 수행해서 원소의 합계를 구할 수 있다.
```kotlin
fun main(){
    val a = IntArray(10) {it * it}
    var sum = 0
    
    for( x in a ){
        sum += x
    }
    println("Sum:  $sum")
}
```
루프는 다음 세 부분으로 이뤄진다.
1. 이터레이션 대상을 담을 변수 정의
2. 이터레이션에 사용할 값들이 담겨 있는 컨테이너를 계산하기 위한 식
3. 루프 몸통에 해당하는 문 ({sum += 1}). 이터레이션 시 이 몸통이 실행된다.

코틀린의 for 루프는 Iterable 인스턴스에 대한 루프를 간편하게 작성하도록 해주는 자바 for-each 루프와
꽤 비슷하다. 배열, 리스트, 집합은 Iterable에 속하며, 사용자가 정의한 타입도 Iterable을 상송할 수 있다.
하지만 코틀린에는 선언, 초기화, 검사 및 갱신으로 구성되는 일반 자바 for 루프에 해당하는 언어 구조가 없다.
코틀린에서는 앞에서 살펴본 while 루프로 이런 루프를 표현하거나, 범위와 진행을 사용하는 for 루프를
통해 표현할 수 있다.