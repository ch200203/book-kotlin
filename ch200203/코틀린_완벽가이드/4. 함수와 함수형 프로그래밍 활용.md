## 4.1 코틀린을 활용한 함수형 프로그래밍

- 함수형 언어는 함수를 일급 시민(first class)로 취급
    - 함수를 다른 일반적인 타입의 값과 똑같이 취급한다.
    - 변수에 값을 대입하거나 변수에서 값을 읽고 함수에 값을 전달하거나 함수가 값을 반환 할 수 있다.


### 4.1.1 고차함수

```kt
fun aggregate(numbers: IntArray, op: (Int, Int) -> Int): Int {
    val result = numbers.firstOrNull() ?: throw IllegalArgumentException("Empty array")

    for (i in 1..numbers.lastIndex) result = op(result, numbers[i])
    
    return result
}

fun sum(numbers: IntArray) =
    aggregate(numbers, { result, op -> result + op })

fun max(numbers: IntArray) =
    aggregate(numbers, { result, op -> if (op > result) op else result })

fun main() {
    println(sum(intArrayOf(1, 2, 3))) // 6 
    println(max(intArrayOf(1, 2, 3))) // 3
}
```
- `op` 파라미터 : op 를 함수처럼 호출 할 수 있다.
- aggregate 함수를 호출하는 쪽에서 람다식을 인자로 넘긴다.

```kt
{ result, op -> result + op }
```
`result`와 `op`는 함수 파라미터 역할을 하며 -> 다음에 오는 식은 결과를 계산하는 식이다.


### 4.1.2 함수타입

함수 타입은 함수처럼 쓰일 수 있는 값들을 표시하는 타입이며 두가지 부분으로 구분된다.
    
1. 괄호로 둘러싸인 파라미터 타입 목록은 함숫값에 전달될 데이터의 종류와 수를 정의한다.
2. 반환 타입은 함수 타입의 함숫값을 호출하면 돌려받게 되는 값의 타입을 정의한다.

- 반환값이 없는 함수라도 함수 타입에서는 반환 타입을 반드시 명시 해야함. &rarr; 이런 경우는 Unit 을 반환타입으로 사용한다.
- 함수 정의에서와 달리 함수 타입 표기에서는 인자 타입 목록과 반환 타입 사이를 : 이 아닌 -> 로 구분한다.
- 함숫값을 호출하는 다른 방법은 `invoke()` 메서드를 사용한다.

> 자바에서는 단일 추상 메서드 인터페이스(Single Abstract Method)를 문맥에 따라 적절히 함수 타입 처럼 취급하기 람다식이나 메서드 참조로(SAM) 인터페이스를 인스턴스화 할 수 있다. 반면에 코틀린에서 함수 값은 항상 (P1, ...., Pn) -> R 형태의 함수 타입에 속하기 때문에 임의의 SAM 함수를 암시적으로 변환이 불가능한다.

함수가 인자를 받지 않는 경우에는 함수 타입의 파라미터 목록이 빈괄호를 사용

파라미터 타입을 둘러싼 괄호는 필수이므로 함수 타입이 파라미터를 하나만 받거나 전혀 받지 않 는 경우에도 괄호를 사용해야한다.


```kt
fun measureTime(action: () -> Unit): Long {
    val start = System.nanoTime()

    action()

    return System.nanoTime() - start
}
```
변수 타입을 생략하면 정보가 충분하지 못해 컴파일러가 람다 파라미터의 타입을 추론할 수 없다.
```kt
val lessThan = { a, b -> a < b } // error

val lessThan = { a: Int, b: Int -> a < b } // Ok
```

함수 타입을 다른 함수 타입 안에 내포시켜서 고차 함수 타입을 정의할 수 있다.
```kt
fun main() {
    val shifter: (Int) -> (Int) -> Int = { n -> { i -> i + n } }

    val inc = shifter(1)
    val dec = shifter(-1)

    println(inc(10)) // 10
    println(dec(10)) // 9
}
```

- 위의 shifter의 (Int) -> (Int) -> Int는 실제로 (Int) -> ((Int) -> Int) 이므로, 'Int값'을 인자로 받아서 '다른 Int를 내놓는 함수 타입'이 된다. 
- 'Int를 받아서 Int를 내놓는 함수'를 인자로 받아서 'Int를 결과로 돌려주는 함수'를 표현하고 싶다면 다음과 같이 하면 된다.
```kt
fun main() {
    val evalAtZero: ((Int) -> (Int)) -> Int = { f -> f(0) }

    println(evalAtZero { n -> n + 1}) // 1
    println(evalAtZero { n -> n - 1}) // -1
}
```
- 함수 타입의 파라미터 목록에 파라미터 이름을 붙일 수 도 있다. 이 경우 이름은 그냥 문서화를 위한 것이며, 함숫값에는 영향을 미치지 못한다.
```kt
fun aggregate(
    numbers: IntArray,
    op: (resultSoFar: Int, nextValue: Int) -> Int
): Int {...}
```

### 4.1.3