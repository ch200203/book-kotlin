## 4.1 코틀린을 활용한 함수형 프로그래밍

- 함수형 언어는 함수를 일급 시민(first class)로 취급
    - 함수를 다른 일반적인 타입의 값과 똑같이 취급한다.
    - 변수에 값을 대입하거나 변수에서 값을 읽고 함수에 값을 전달하거나 함수가 값을 반환 할 수 있다.


### 4.1.1 고차함수

```kt
fun aggregate(numbers: IntArray, op: (Int, Int) -> Int): Int {
    val result = numbers.firstOrNull() ?: throw IllegalArgumentException("Empty array")

    for (i in 1..numbers.lastIndex) result = op(result, numbers[i])
    
    return result
}

fun sum(numbers: IntArray) =
    aggregate(numbers, { result, op -> result + op })

fun max(numbers: IntArray) =
    aggregate(numbers, { result, op -> if (op > result) op else result })

fun main() {
    println(sum(intArrayOf(1, 2, 3))) // 6 
    println(max(intArrayOf(1, 2, 3))) // 3
}
```
- `op` 파라미터 : op 를 함수처럼 호출 할 수 있다.
- aggregate 함수를 호출하는 쪽에서 람다식을 인자로 넘긴다.

```kt
{ result, op -> result + op }
```
`result`와 `op`는 함수 파라미터 역할을 하며 -> 다음에 오는 식은 결과를 계산하는 식이다.


### 4.1.2 함수타입

함수 타입은 함수처럼 쓰일 수 있는 값들을 표시하는 타입이며 두가지 부분으로 구분된다.
    
1. 괄호로 둘러싸인 파라미터 타입 목록은 함숫값에 전달될 데이터의 종류와 수를 정의한다.
2. 반환 타입은 함수 타입의 함숫값을 호출하면 돌려받게 되는 값의 타입을 정의한다.

- 반환값이 없는 함수라도 함수 타입에서는 반환 타입을 반드시 명시 해야함. &rarr; 이런 경우는 Unit 을 반환타입으로 사용한다.
- 함수 정의에서와 달리 함수 타입 표기에서는 인자 타입 목록과 반환 타입 사이를 : 이 아닌 -> 로 구분한다.
- 함숫값을 호출하는 다른 방법은 `invoke()` 메서드를 사용한다.

> 자바에서는 단일 추상 메서드 인터페이스(Single Abstract Method)를 문맥에 따라 적절히 함수 타입 처럼 취급하기 람다식이나 메서드 참조로(SAM) 인터페이스를 인스턴스화 할 수 있다. 반면에 코틀린에서 함수 값은 항상 (P1, ...., Pn) -> R 형태의 함수 타입에 속하기 때문에 임의의 SAM 함수를 암시적으로 변환이 불가능한다.

함수가 인자를 받지 않는 경우에는 함수 타입의 파라미터 목록이 빈괄호를 사용

파라미터 타입을 둘러싼 괄호는 필수이므로 함수 타입이 파라미터를 하나만 받거나 전혀 받지 않 는 경우에도 괄호를 사용해야한다.


```kt
fun measureTime(action: () -> Unit): Long {
    val start = System.nanoTime()

    action()

    return System.nanoTime() - start
}
```
변수 타입을 생략하면 정보가 충분하지 못해 컴파일러가 람다 파라미터의 타입을 추론할 수 없다.
```kt
val lessThan = { a, b -> a < b } // error

val lessThan = { a: Int, b: Int -> a < b } // Ok
```

함수 타입을 다른 함수 타입 안에 내포시켜서 고차 함수 타입을 정의할 수 있다.
```kt
fun main() {
    val shifter: (Int) -> (Int) -> Int = { n -> { i -> i + n } }

    val inc = shifter(1)
    val dec = shifter(-1)

    println(inc(10)) // 10
    println(dec(10)) // 9
}
```

- 위의 shifter의 (Int) -> (Int) -> Int는 실제로 (Int) -> ((Int) -> Int) 이므로, 'Int값'을 인자로 받아서 '다른 Int를 내놓는 함수 타입'이 된다. 
- 'Int를 받아서 Int를 내놓는 함수'를 인자로 받아서 'Int를 결과로 돌려주는 함수'를 표현하고 싶다면 다음과 같이 하면 된다.
```kt
fun main() {
    val evalAtZero: ((Int) -> (Int)) -> Int = { f -> f(0) }

    println(evalAtZero { n -> n + 1}) // 1
    println(evalAtZero { n -> n - 1}) // -1
}
```
- 함수 타입의 파라미터 목록에 파라미터 이름을 붙일 수 도 있다. 이 경우 이름은 그냥 문서화를 위한 것이며, 함숫값에는 영향을 미치지 못한다.
```kt
fun aggregate(
    numbers: IntArray,
    op: (resultSoFar: Int, nextValue: Int) -> Int
): Int {...}
```

### 4.1.3 람다와 익명함수

람다식 : 함수를 묘사하되 이름을 지정하지는 않는 함수

```kt
{ result, op -> result + op }라는 식을 람다식이고 부른다.
```
- **파라미터 목록**: result, op
- **람다식의 몸통(본문)이 되는 식이나 문의 목록**: result + op

- 함수 정의와 달리 반환 타입을 지정할 필요가 없으며, 람다의 본문으로부터 반환 타입이 자동으로
추론된다. 
- 람다 본문에서 맨 마지막에 있는 식이 람다의 결괏값이 된다.
- 람다 정의에서 파라미터를 괄호로 감싸면 구조 분해(destructuring) 선언이 된다
- 람다가 함수의 마지막 파라미터인 경우, 함수를 호출할 때 인자를 둘러싸는 괄호 밖에 이 람다를 위치시킬 수 있다 (코틀린 권장 방법)
```kt
fun sum(numbers: IntArray) =
aggregate(numbers) { result, op -> result + op }
fun max(numbers: IntArray) =
aggregate(numbers) { result, op -> if (op > result) op else result }

// 인자가 없으면 화살표 생략가능
val time = measureTime{ 1 + 2 }
```

- 인자가 하나인 경우에는 파라미터 목록과 화살표 기호를 생략하고, 유일한 파라미터는 미리 정해 진 **it**이라는 이름을 사용해 가리킬 수 있다.
- 람다의 파라미터 목록에서 사용하지 않는 람다 파라미터를 밑줄 기호(_)로 지정 할 수 있다.

```kt
fun check(s: String, condition: (Int, Char) -> Boolean): Boolean { 
    for (i in s.indices) {
        if (!condition(i, s[i])) return false 
    }
    return true 
}

fun main() {
    println(check("Hello") { _, c ->c.isLetter() })  // true
    println(check("Hello") { i, c ->i == 0 || c.isLowerCase() }) // true
}
```

익명함수 사용 방법

```kt
fun sum(numbers: IntArray) =
    aggregate(numbers, fun(result, op) = result + op)
```
- 익명함수에는 이름을 지정하지 않는다.
    - `fun` 키워드 다음 파라미터 목록이 온다.
- 파라미터 타입을 추론할 수 있으면 파라미터 타입을 지정하지 않아도 된다.
- 익명함수는 식이기 때문에 인자로 함수에 넘기거나 변수에 대입하는등 일반값처럼 쓸 수 있다.
- 익명 함수에서는 반환 타입을 적을 수 있다
    - 함수 본문이 블록인 경우 명시적으로 반환타입을 명시해 주어야 한다.
- 익명 함수도 클로저, 또는 자신을 포함하는 외부 선언에 정의된 변수에 접근할 수 있다
    - 람다나 익명 함수도 외부 영역의 가변 변수 값을 변경할 수 있다.
```kt
fun forEach(a: IntArray, action: (Int) -> Unit) { 
    for (n in a) {
        action(n) 
    }
}

fun main() {
    var sum = 0
    
    forEach(intArrayOf(1, 2, 3, 4)) {
sum += it }
println(sum) // 10 }
```

> 자바 람다는 외부 변수의 값을 변경 할 수 없다.

### 4.1.4 호출 가능 참조

호출 가능 참조(callable reference)
- `::isCapitalLetter`라는 식은 이 식이 가리키는 `isCapitalLetter()` 함수와 같은 동작을 하는 함숫값을 표현해준다

```kt
fun main() {
    println(check("Hello", ::isCapitalLetter)) // false
}
```

- 가장 간단한 형태의 호출 가능 참조는 최상위나 지역 함수를 가리키는 참조다.
- 함수 이름 앞에 `::`을 붙이면 된다.
- 호출 가능 참조를 만들 때는 함수 이름을 간단한 형태로만 써야 한다. 
- `::`을 클래스 이름 앞에 적용하면 클래스의 생성자에 대한 호출 가능 참조를 얻는다.
```kt
class Person(val firstName: String, val familyName: String)

fun main() {
    val createPerson= ::Person createPerson("John", "Doe")
}
```

**바인딩된 호출 가능 참조(bound callable reference)**

```kt
class Person(val firstName: String, val familyName: String) { 
    fun hasNameOf(name: String) = name.equals(firstName,ignoreCase = true)
}

fun main() {
    val isJohn = Person("John", "Doe")::hasNameOf

    println(isJohn("JOHN")) // true
    println(isJohn("Jake")) // false 
}
```

- 호출 가능 참조 자체는 오버로딩된 함수를 구분 할 수 없다.
- 오버로딩된함수중 어떤 함수를 참조할지 명확히 하려면 컴파일러에게(물론 사람에게도) 타입을 지정해줘야 한다.

```kt
fun max(a: Int, b: Int) = if (a > b) a else b
fun max(a: Double, b: Double) = if (a > b) a else b

val f: (Int, Int) -> Int = ::max // Ok
val g = ::max // error: overload resolution ambiguity
```
-  호출 가능 참조를 직접 호 출하고 싶다면 참조 전체를 괄호로 둘러싼 다음에 인자를 지정해야 한다.
```kt
println((::max)(1, 2)) // 2
```

프로퍼티에 대한 호출 가능 참조
- 참조 자체는 실제로는 함숫값이 아니고, 프로퍼티 정보를 담고 있는 리플렉션(reflection) 객체
- var 선언의 경우에는 리플렉션 객체의 setter 프로퍼티를 통해 세터 함수에 접근할 수 있다
```kt
class Person(var firstName: String, var familyName: String)

fun main() {
    val person = Person("John", "Doe") 
    val readName = person::firstName.getter
    val writeFamily = person::familyName.setter // 세터 참조

    println(readName()) // John 
    writeFamily("Smith") 
    println(person.familyName) // Smith
}
```

> 자바의 메서드 참조와의 차이점 
> - 호출 가능 참조는 자바의 메서드 참 조보다 종류가 더 많다
> - 코틀린의 호출 가능 참조는 일급 시민 식이지만, 자바 메서드 참조 는 함수형 인터페이스 내에서만 의미가 있다 (자바의 메서드 참조에는 정해진 타입이 없음)


### 4.1.5 인라인함수와 프로퍼티

함숫값을 사용하는 고차 함수를 호출하는 부분을 해당 함수의 본문으로 대체 하는 인라인(inline) 기법을 사용한다.
- 고차 함수와 함숫값을 사용하면 함수가 객체로 표현되기 때문에 성능 차원에서 부가 비용이 발생
- 인라인 함수를 쓰면 컴파일된 코드의 크기가 커지지만, 지혜롭게 사용하면 성능을 크게 높일 수 있다.
- 대상 함수가 상대적으로 작은 경우 성능이 크게 향상
- `inline이` 붙은 코틀린 함수는 가능하면 항상 인라이닝이 되며, 인라이닝이 불가능한 경우에는 컴파일 오류로 간주된다.