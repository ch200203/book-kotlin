# 5. 특별한 클래스 사용하기

## 5.1 Enum Class

- 정해진 상수들로 이뤄진 집합을 타입 안전(type-safe)하게 다룰 수 있 다.

> 코틀린 이넘은 enum class라는 두 키워드의 조합으로 정의되지만, 자바는 enum만 으로 정의된다. enum 키워드 자체는 소프트 키워드이므로 다른 문맥에서는 식별자로 사용할 수 있다.

- 컴파일 시점 상수이므로 이넘 값을 쓸 때는 보통 대문자를 사용한다.
- 객체와 마찬가지로 전역 상수로 사용할 수 있는 방법이 없는 위치에서는 이넘을 정의할 수없다.


### 5.1.1 빠뜨린 부분이 없는 when 식

- when 식에서 모든 enum 상수를 다룬경우에는 else 가지 를 생략해도 된다.
- 새 Enum 값이 추가되는 경우에도 코드가 꺠지는 경우를 방지해준다.
```kt
enum class Direction {
    NORTH, SOUTH, WEST, EAST
}

fun rotateClockWise(direction: Direction) = when (direction) {
    Direction.   NORTH -> Direction.EAST
    Direction.EAST -> Direction.SOUTH
    Direction.SOUTH -> Direction.WEST
    Direction.WEST -> Direction.NORTH 
}
```
-> 컴파일 시점에 컴파일러가 `rotateClockWise()` 함수의 `when`에 빠뜨린 부분이 있다고 경고하기 때문에 이런 오류를 쉽게 방지할 수 있다.

- 내부적으로 빠진 부분이 없는 when 식에는 `NoWhenBranchMatchedException` 타입의 예외를 던지는 else 가지가 암시적으로 추가된다.

### 5.1.2 커스텀 멤버가 있는 Enum 정의

- enum 클래스에도 멤버를 포함 가능
- 이넘에도 확장함수, 프로퍼티 추가 가능
- enum 클래스에 정의된 이런 요소들은 반드시 이넘 상수 목록 뒤에 와야 한다. 
    - 이런 경우에는 상수 목록과 다른 부분을 구분하기 위해 상수 목록을 세미콜론으로 끝내야 한다
- 이넘 상수 본문에 정의된 내포된 클래스들이 반드시 내부 클래스여야 한다

```kt
enum class RainbowColor(val isCold: Boolean) { 
    RED(false), ORANGE(false), YELLOW(false), GREEN(true), BLUE(true), INDIGO(true), VIOLET(true);

    val isWarm get() = !isCold
}

fun main() {
    println(RainbowColor.BLUE.isCold) // true 
    println(RainbowColor.RED.isWarm) // true 
}
```

### 5.1.3 Enum class 공통 멤버 사용하기

- 모든 enum 클래스는 암시적으로 kotlin.Enum 클래스의 하위 타입
    - 따라서, 공통 함수와 프로퍼티를 제공한다.
- 모든 이넘 값에는 `ordinal`과 `name` 가 포함
    - ordinal : 이넘 클래스 안 에 정의된 이넘 값의 순서에 따른 인덱스
    - name : 이넘 값의 이름이다.
- 특정 이넘 클래스의 값을 이넘 본문에 있는 정의의 위치에 따라 서로 비교할 수 있다.
    - 이넘 값에 대한 비교는 ordinal 프로퍼티가 돌려주는 인덱스 값에 의해 정의된다.

```kt
fun main() {
    println(Direction.WEST == Direction.NORTH) // false
    println(Direction.WEST != Direction.EAST) // true
    println(Direction.EAST < Direction.NORTH) // false
    println(Direction.SOUTH >= Direction.NORTH) // true
}
```
- enum 값에 대한 비교는 ordinal 프로퍼티가 돌려주는 인덱스 값에 의해 정의

- 암시적으로 정의된 메서드 제공
    - `valueOf()` : 이넘 값의 이름을 문자열로 넘기면 그에 해당하는 이넘 값을 돌려주거나 이 름이 잘못된 경우 예외를 던진다.
    - `values()` : 정의된 순서대로 모든 이넘 값이 들어있는 배열을 돌려준다. 이 메서드를 호출 할 때 마다 배열이 새로 생긴다.

- 코틀린 1.1부터는 values()나 valueOf() 대신에 제네릭(generic) 최상위 메서드인 `enumValues()`와 `enumValueOf()`를 사용할 수도 있다.

```kt
// valueOf
fun main() {
    println(Direction.valueOf("NORTH"))
    // java.lang.IllegalArgumentException: No enum constant NORTH_EAST println(Direction.valueOf("NORTH_EAST"))
}

// values
enum class WeekDay {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

private val weekDays = WeekDay.values()

val WeekDay.nextDay get() = weekDays[(ordinal + 1) % weekDays.size]

// enumValues and enumValueOf
fun main() {
    val weekDays = enumValues<WeekDay>()
    println(weekDays[2]) // WEDNESDAY
    println(enumValueOf<WeekDay>("THURSDAY")) // THURSDAY
}
```

## 5.2 Data Class

- 데이터를 저장하기 위한 목적으로 주로 쓰이는 클래스를 선언
- 컴파일러가 동등성을 비교하거나 String으로 변환하는 등의 기본 연산에 대한 구현을 자동으로 생성
- 구조 분해 선언(destructuring declaration)을 활용
    - 클래스의 프로퍼티를 간단한 한가지 언어구성 요소를 사용해 여러 변수에 나눠 넣을 수 있다.

### 6.2.1 데이터 클래스와 데이터 클래스에 대한 연산

- 클래스의 두 인스턴스가 동등한지 비교 => 메모리에서 같은 위치에 있는 객체인지 비교
- 이때 인스턴스의 필 드 값이 같은지는 고려 대상이 아니다.
- 컴파일러가 주생성자에 정의된 프로퍼티의 값을 서로 비교하는 동등성 비교 연산을 자동 으로 생성
- 이 클래스의 `hashCode()` 메서드도 주생성자에 정의된 프로퍼티의 값에 따라 결정
- 프로퍼티 값의 비교도 equals() 메서드를 통한다
- 깊은 동등성(deep equality) 비교가 이뤄지는지 여부는 프로퍼티의 타입으로 어떤 타입이 들어있느냐에 따라 달라진다

- `hashCode()` 메서드 구현도 주생성자에 선언된 모든 프로퍼티의 해시 코드에 의존해 계산한 해시
코드를 반환한다


```kt
data class Person(val firstName: String, val familyName: String,
val age: Int)

data class Mailbox(val address: String, val person: Person)

fun main() {
    val box1 = Mailbox("Unknown", Person("John", "Doe", 25)) 
    val box2 = Mailbox("Unknown", Person("John", "Doe", 25)) 
    println(box1 == box2) // true
}
```

- 모든 데이터 클래스는 암시적으로 `copy()` 함수를 제공
    - 현재 인스턴스를 복사하면서 몇몇 프로퍼티를 변경할 수 있다.
    - copy() 함수의 시그니처는 데이터 클래스의 주생성 자 시그니처와 같다.
    - 각 프로퍼티마다 원본 객체의 프로퍼티 값이 디폴트 값으로 지정된다.
    - 코드 가독성을 위해 copy() 함수를 호출할 때는 보통 이름 붙은 인자 구문을 사용한다.
